package com.roundfeather.persistence.utils.datastore;

import com.google.cloud.datastore.Datastore;
import com.google.cloud.datastore.Query;

import java.lang.reflect.ParameterizedType;
import java.util.Arrays;
import java.util.List;

import com.roundfeather.persistence.utils.datastore.annotation.DatastoreEntity;
import com.roundfeather.persistence.utils.datastore.annotation.DatastoreKey;

/**
 * Repository interface for interacting with Google Datastore.
 *
 * <p>
 *     An implementation is automatically generated during compilation by default for any class annotated with
 *     {@link DatastoreEntity}
 * </p>
 *
 * <p>
 *     To use an instance of a repository you can simply Inject one for your Entity type
 * </p>
 *
 * Example:
 * <pre>
 * {@code
 * @Inject
 * DatastoreRepository<YourObject> repository;
 *}
 * </pre>
 *
 * @param <E> Type of {@link Object} the repository is for
 *
 * @since 1.0
 */
@SuppressWarnings({"squid:S3740"})
public interface DatastoreRepository<E> {

    /**
     * Queries the Datastore entity corresponding to the {@code value()} of the {@link DatastoreEntity} for the {@link E}
     * to get all objects corresponding to the given list of ancestors
     *
     * <p>
     *     Ancestors will be applied in the order provided when generating the Datastore query
     * </p>
     *
     * @param dsNamespace The namespace to query
     * @param ancestors List of ancestors to apply to the query
     * @return List of objects of type {@link E} found in Datastore with the given ancestors
     *
     * @since 1.0
     */
    default List<E> list(DatastoreNamespace dsNamespace, Ancestor... ancestors) {
        return list(dsNamespace, Arrays.stream(ancestors).toList());
    }

    /**
     * Queries the Datastore entity corresponding to the {@code value()} of the {@link DatastoreEntity} for the {@link E}
     * to get all objects corresponding to the given list of ancestors
     *
     * <p>
     *     Ancestors will be applied in the order provided when generating the Datastore query
     * </p>
     *
     * @param dsNamespace The namespace to query
     * @param ancestors List of ancestors to apply to the query
     * @return List of objects of type {@link E} found in Datastore with the given ancestors
     *
     * @since 1.0
     */
    default List<E> list(DatastoreNamespace dsNamespace, List<Ancestor> ancestors) {
        Class tp = (Class) ((ParameterizedType) this.getClass().getGenericInterfaces()[0]).getActualTypeArguments()[0];
        return DatastoreOperations.getInstance().list(dsNamespace, tp, ancestors);
    }

    /**
     * Queries the Datastore entity corresponding to the {@code value()} of the {@link DatastoreEntity} for the {@link E}
     * to get the object corresponding to the given key and list of ancestors
     *
     * <p>
     *     Ancestors will be applied in the order provided when generating the Datastore query
     * </p>
     *
     * @param dsNamespace The namespace to query
     * @param key The unique key of the entity to find
     * @param ancestors List of ancestors to apply to the query
     * @return Object of type {@link E} if found, otherwise null
     *
     * @since 1.0
     */
    default E find(DatastoreNamespace dsNamespace, Key key, Ancestor... ancestors) {
        return find(dsNamespace, key, Arrays.stream(ancestors).toList());
    }

    /**
     * Queries the Datastore entity corresponding to the {@code value()} of the {@link DatastoreEntity} for the {@link E}
     * to get the object corresponding to the given key and list of ancestors
     *
     * <p>
     *     Ancestors will be applied in the order provided when generating the Datastore query
     * </p>
     *
     * @param dsNamespace The namespace to query
     * @param key The unique key of the entity to find
     * @param ancestors List of ancestors to apply to the query
     * @return Object of type {@link E} if found, otherwise null
     *
     * @since 1.0
     */
    default E find(DatastoreNamespace dsNamespace, Key key, List<Ancestor> ancestors) {
        Class tp = (Class) ((ParameterizedType) this.getClass().getGenericInterfaces()[0]).getActualTypeArguments()[0];
        return (E) DatastoreOperations.getInstance().get(dsNamespace, tp, key, ancestors);
    }

    /**
     * Saves an Object of type {@link E} to Datastore entity corresponding to the {@code value()} of the
     * {@link DatastoreEntity} for the {@link E}
     *
     * <p>
     *     If the object does not have a field annotated with {@link DatastoreKey}, it cannot be serialized and written
     *     to Datastore
     * </p>
     *
     * @param dsNamespace Namespace to write the object to
     * @param e Object to save
     * @return The written object, including any autogenerated key fields
     *
     * @since 1.0
     */
    default E save(DatastoreNamespace dsNamespace, E e) {
        return save(dsNamespace, e, true, List.of());
    }

    /**
     * Saves an Object of type {@link E} to Datastore entity corresponding to the {@code value()} of the
     * {@link DatastoreEntity} for the {@link E} with additional Ancestors not found in the object.
     *
     * <p>
     *     If the object does not have a field annotated with {@link DatastoreKey}, it cannot be serialized and written
     *     to Datastore
     * </p>
     * <p>
     *     The addition ancestors will be prepended to the ancestors in the object
     * </p>
     *
     * @param dsNamespace Namespace to write the object to
     * @param e Object to save
     * @param additionalAncestors List of ancestors to include when in the Entity's key
     * @return The written object, including any autogenerated key fields
     *
     * @since 1.0
     */
    default E save(DatastoreNamespace dsNamespace, E e, Ancestor... additionalAncestors) {
        return save(dsNamespace, e, true, Arrays.stream(additionalAncestors).toList());
    }

    /**
     * Saves an Object of type {@link E} to Datastore entity corresponding to the {@code value()} of the
     * {@link DatastoreEntity} for the {@link E} with additional Ancestors not found in the object.
     *
     * <p>
     *     If the object does not have a field annotated with {@link DatastoreKey}, it cannot be serialized and written
     *     to Datastore
     * </p>
     * <p>
     *     The addition ancestors will be prepended to the ancestors in the object
     * </p>
     *
     * @param dsNamespace Namespace to write the object to
     * @param e Object to save
     * @param additionalAncestors List of ancestors to include when in the Entity's key
     * @return The written object, including any autogenerated key fields
     *
     * @since 1.0
     */
    default E save(DatastoreNamespace dsNamespace, E e, List<Ancestor> additionalAncestors) {
        return save(dsNamespace, e, true, additionalAncestors);
    }

    /**
     * Saves an Object of type {@link E} to Datastore entity corresponding to the {@code value()} of the
     * {@link DatastoreEntity} for the {@link E} with additional Ancestors not found in the object.
     *
     * <p>
     *     If the object does not have a field annotated with {@link DatastoreKey}, it cannot be serialized and written
     *     to Datastore
     * </p>
     *
     * @param dsNamespace Namespace to write the object to
     * @param e Object to save
     * @param prependAdditionalAncestors If the additional ancestors should be added before or after the ancestors in the object
     * @param additionalAncestors List of ancestors to include when in the Entity's key
     * @return The written object, including any autogenerated key fields
     *
     * @since 1.0
     */
    default E save(DatastoreNamespace dsNamespace, E e, boolean prependAdditionalAncestors, Ancestor... additionalAncestors) {
        return save(dsNamespace, e, prependAdditionalAncestors, Arrays.stream(additionalAncestors).toList());
    }

    /**
     * Saves an Object of type {@link E} to Datastore entity corresponding to the {@code value()} of the
     * {@link DatastoreEntity} for the {@link E} with additional Ancestors not found in the object.
     *
     * <p>
     *     If the object does not have a field annotated with {@link DatastoreKey}, it cannot be serialized and written
     *     to Datastore
     * </p>
     *
     * @param dsNamespace Namespace to write the object to
     * @param e Object to save
     * @param prependAdditionalAncestors If the additional ancestors should be added before or after the ancestors in the object
     * @param additionalAncestors List of ancestors to include when in the Entity's key
     * @return The written object, including any autogenerated key fields
     *
     * @since 1.0
     */
    default E save(DatastoreNamespace dsNamespace, E e, boolean prependAdditionalAncestors, List<Ancestor> additionalAncestors) {
        return (E) DatastoreOperations.getInstance().persist(dsNamespace, e, additionalAncestors, prependAdditionalAncestors);
    }

    /**
     * Deletes an object from Datastore entity corresponding to the {@code value()} of the {@link DatastoreEntity} for
     * the {@link E} corresponding to the given key and list of ancestors
     *
     * <p>
     *     Ancestors will be applied in the order provided when generating the Datastore query
     * </p>
     *
     * @param dsNamespace Namespace to delete object from
     * @param key The unique key of the entity to delete
     * @param ancestors List of ancestors for the entity
     * @return The deleted object of type {@link E}
     *
     * @since 1.0
     */
    default E delete(DatastoreNamespace dsNamespace, Key key, Ancestor... ancestors) {
        return delete(dsNamespace, key, Arrays.stream(ancestors).toList());
    }

    /**
     * Deletes an object from Datastore entity corresponding to the {@code value()} of the {@link DatastoreEntity} for
     * the {@link E} corresponding to the given key and list of ancestors
     *
     * <p>
     *     Ancestors will be applied in the order provided when generating the Datastore query
     * </p>
     *
     * @param dsNamespace Namespace to delete object from
     * @param key The unique key of the entity to delete
     * @param ancestors List of ancestors for the entity
     * @return The deleted object of type {@link E}
     *
     * @since 1.0
     */
    default E delete(DatastoreNamespace dsNamespace, Key key, List<Ancestor> ancestors) {
        Class tp = (Class) ((ParameterizedType) this.getClass().getGenericInterfaces()[0]).getActualTypeArguments()[0];
        return (E) DatastoreOperations.getInstance().delete(dsNamespace, tp, key, ancestors);
    }

    /**
     * Runs a custom Datastore query
     *
     * @param query Custom Datastore Query to run.
     * @return List of objects of type {@link E} that match the query
     *
     * @since 1.0
     */
    default List<E> eval(Query query) {
        Class tp = (Class) ((ParameterizedType) this.getClass().getGenericInterfaces()[0]).getActualTypeArguments()[0];
        return DatastoreOperations.getInstance().eval(query, tp);
    }

    /**
     * Exposes internal {@link Datastore} client object in case there is a unique use-case
     *
     * @return Google Datastore object
     *
     * @since 1.0
     */
    default Datastore getDatastore() {
        return DatastoreOperations.getInstance().getDatastore();
    }
}
